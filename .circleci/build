#!/bin/bash
#
# Builds a docker image and pushes it to it's repository. Leverages caches where possible.
# Cached images include previous images built on this branch, otherwise use images from master at fork point.
# The images output are cache images, meaning they will eventually get purged.
# The deploy phase will tag the images such that they become permanent.
#
# usage: ./build <repository> [dockerfile]
# example (branch cl/feature): ./build barretenberg-x86_64-linux-clang
# output image tags:
#   278380418400.dkr.ecr.us-east-2.amazonaws.com/barretenberg-x86_64-linux-clang:cache-cl_feature
#   278380418400.dkr.ecr.us-east-2.amazonaws.com/barretenberg-x86_64-linux-clang:cache-deadbeefcafebabe1337c0d3

set -ex

REPOSITORY=$1
BRANCH=${CIRCLE_BRANCH//\//_}
MASTER_TAG=master-$LAST_SUCCESSFUL_COMMIT
IMAGE_MASTER_URI=$ECR_URL/$REPOSITORY:$MASTER_TAG
IMAGE_BRANCH_URI=$ECR_URL/$REPOSITORY:cache-$BRANCH
IMAGE_COMMIT_URI=$ECR_URL/$REPOSITORY:cache-$CIRCLE_SHA1
DOCKERFILE=${2:-./Dockerfile}

# Ensure ECR repository exists.
ensure_repo $REPOSITORY $ECR_REGION

# Check if we should rebuild.
check_rebuild || ! image_exists $REPOSITORY $MASTER_TAG || { echo "No rebuild necessary." && exit 0; }

function fetch_image() {
  echo "Pulling: $1"
  if ! docker pull $1 > /dev/null 2>&1; then
    echo "Image not found: $1"
    return 1
  fi
  return 0
}

# Pull latest parents that are not ours.
PARENTS=$(cat $DOCKERFILE | sed -n -e 's/^FROM \([^[:space:]]\+\).*/\1/p' | grep -v $ECR_DEPLOY_URL | sort | uniq)
for PARENT in $PARENTS; do
  fetch_image $PARENT
done

# For each parent that's ours, pull in the newly rebuilt image if it's present.
# If it's not present, there must be a master image to use.
PARENTS=$(cat $DOCKERFILE | sed -n -e "s/^FROM $ECR_DEPLOY_URL\/\([^[:space:]]\+\)/\1/p")
for PARENT in $PARENTS; do
  PARENT_REPO=${PARENT%:*}
  PARENT_IMAGE_URI=$ECR_URL/$PARENT_REPO:cache-$CIRCLE_SHA1
  if ! fetch_image $PARENT_IMAGE_URI; then
    PARENT_IMAGE_URI=$ECR_URL/$PARENT_REPO:$MASTER_TAG
    fetch_image $PARENT_IMAGE_URI
  fi
  docker tag $PARENT_IMAGE_URI $ECR_DEPLOY_URL/$PARENT
done

# Pull image from cache.
echo "Pulling previous build of $REPOSITORY..."
fetch_image $IMAGE_BRANCH_URI || fetch_image $IMAGE_MASTER_URI || true
CACHE_FROM="--cache-from $IMAGE_BRANCH_URI --cache-from $IMAGE_MASTER_URI"
echo

# Pull, build and push each named stage to cache.
STAGES=$(cat $DOCKERFILE | sed -n -e 's/^FROM .* AS \(.*\)/\1/p')
for STAGE in $STAGES; do
  echo "Pulling stage: $STAGE"
  STAGE_IMAGE_MASTER_URI=$ECR_URL/$REPOSITORY:cache-master-$STAGE
  STAGE_IMAGE_BRANCH_URI=$ECR_URL/$REPOSITORY:cache-$BRANCH-$STAGE

  fetch_image $STAGE_IMAGE_BRANCH_URI || fetch_image $STAGE_IMAGE_MASTER_URI || true
  STAGE_CACHE_FROM="--cache-from $STAGE_IMAGE_BRANCH_URI --cache-from $STAGE_IMAGE_MASTER_URI"
  CACHE_FROM="$CACHE_FROM $STAGE_CACHE_FROM"

  echo "Building stage: $STAGE"
  docker build --target $STAGE $STAGE_CACHE_FROM -t $STAGE_IMAGE_BRANCH_URI -f $DOCKERFILE .

  echo "Pushing stage: $STAGE"
  docker push $STAGE_IMAGE_BRANCH_URI > /dev/null 2>&1
  echo
done

echo "Building image: $IMAGE_BRANCH_URI, $IMAGE_COMMIT_URI"
docker build -t $IMAGE_BRANCH_URI -t $IMAGE_COMMIT_URI -f $DOCKERFILE $CACHE_FROM .
echo "Pushing image: $IMAGE_BRANCH_URI"
docker push $IMAGE_BRANCH_URI > /dev/null 2>&1
echo "Pushing image: $IMAGE_COMMIT_URI"
docker push $IMAGE_COMMIT_URI > /dev/null 2>&1
echo

if [ -d ./terraform ]; then
  ensure_terraform
  export TF_IN_AUTOMATION=1
  cd terraform
  for DIR in . $(find . -maxdepth 1 -type d); do
    pushd $DIR
    if [ -f ./main.tf ]; then
      terraform init -input=false
      terraform validate
    fi
    popd
  done
fi